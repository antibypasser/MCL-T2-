function Write-ColoredLine {
param (
[string]$Text,
[ConsoleColor]$Color = 'White'
)
$oldColor = $Host.UI.RawUI.ForegroundColor
$Host.UI.RawUI.ForegroundColor = $Color
Write-Host $Text
$Host.UI.RawUI.ForegroundColor = $oldColor
}
# --- INTRO SCREEN ---
Clear-Host
Write-Host " _____ _____  _      ____             ____        _           " -ForegroundColor Yellow
Write-Host "| ____|_   _|/ \    |  _ \ ___  ___  |  _ \ _   _| | ___  ___ " -ForegroundColor Yellow
Write-Host "|  _|   | | / _ \   | |_) / _ \/ __| | |_) | | | | |/ _ \/ __|" -ForegroundColor Yellow
Write-Host "| |___  | |/ ___ \  |  _ <  __/ (__  |  _ <| |_| | |  __/\__ \" -ForegroundColor Yellow
Write-Host "|_____| |_/_/   \_\ |_| \_\___|\___| |_| \_\\__,_|_|\___||___/" -ForegroundColor Yellow
Write-Host ""
Write-ColoredLine "=== Recording Rule Hub ===" Yellow
Write-ColoredLine "Complete all steps with 100% success to pass." White
Write-Host ""
Write-ColoredLine "1. ZIPs will download to C:\ToolsETA" Green
Write-ColoredLine "2. They auto-extract and apply per window." Green
Write-Host ""
Write-ColoredLine "discord.gg/mcl" Magenta
Write-ColoredLine "discord.gg/rivalsleague" Magenta
Write-ColoredLine "discord.gg/eta" Magenta
Write-ColoredLine "discord.gg/etajd" Red
Write-Host ""
Write-ColoredLine "Made by @ravenader1" Blue
Write-ColoredLine "Made by @cyberthreats" Blue
Write-Host ""
Read-Host "Press Enter to begin Step 1..."
Clear-Host
# --- STEP 1: SYSTEM CHECK ---
Write-ColoredLine "Step 1: SYSTEM Check - by @cyberthreats" Cyan
# Timer Start
$startTime = Get-Date
# Single-line Progress Bar
for ($i = 0; $i -le 10; $i++) {
$percent = $i * 10
$bar = "#" * $i + "-" * (10 - $i)
Write-Host -NoNewline "`r[ $bar ] $percent%"
Start-Sleep -Milliseconds 200
}
Write-Host ""
# Initialize output
$exclusionsOutput = @()
$defenderOutput = @()
$modulesOutput = @()
$windowsOutput = @()
$memoryIntegrityOutput = @()
$threatsOutput = @()
$powershellSigOutput = @()
# Default modules
$defaultModules = @(
"Microsoft.PowerShell.Archive", "Microsoft.PowerShell.Diagnostics", "Microsoft.PowerShell.Host",
"Microsoft.PowerShell.LocalAccounts", "Microsoft.PowerShell.Management", "Microsoft.PowerShell.Security",
"Microsoft.PowerShell.Utility", "PackageManagement", "PowerShellGet", "PSReadLine", "Pester", "ThreadJob"
)
$protectedModule = "Microsoft.PowerShell.Operation.Validation"
$modulesPath = "C:\Program Files\WindowsPowerShell\Modules"
$deletedAny = $false
$protectedFilePath = "$modulesPath\$protectedModule\1.0.1\Diagnostics\Comprehensive\Comprehensive.Tests.ps1"
$expectedHash = "99B7CBE4325BA089DD9440A202B9E35D9E6F134A46312F3F1E93E71F23C8DAE3"
# Module check
Get-ChildItem $modulesPath -ErrorAction SilentlyContinue | Where-Object { $_.PSIsContainer } | ForEach-Object {
$moduleName = $_.Name
$modulePath = $_.FullName
$isDefault = $defaultModules -contains $moduleName
$isProtected = $moduleName -eq $protectedModule
$files = Get-ChildItem $modulePath -Recurse -Force -ErrorAction SilentlyContinue | Where-Object { -not $_.PSIsContainer }
$unauthorizedFiles = @()
foreach ($file in $files) {
$sig = Get-AuthenticodeSignature $file.FullName
if ($sig.Status -ne 'Valid' -or $sig.SignerCertificate.Subject -notmatch "Microsoft") {
$unauthorizedFiles += $file
}
}
if (-not $isDefault -and -not $isProtected) {
foreach ($file in $files) { try { $file.Attributes = 'Normal' } catch {} }
try {
Remove-Item $modulePath -Recurse -Force -ErrorAction Stop
$modulesOutput += "FAILURE: Removed unauthorized module: $moduleName"
$deletedAny = $true
} catch {
$modulesOutput += "WARNING: Could not delete module '$moduleName'"
}
} elseif ($isProtected) {
if ($unauthorizedFiles.Count -eq 0) {
$modulesOutput += "SUCCESS: Protected module '$moduleName' verified."
} else {
foreach ($file in $unauthorizedFiles) {
if ($file.FullName -ieq $protectedFilePath) {
try {
$bytes = [System.IO.File]::ReadAllBytes($file.FullName)
$sha256 = [System.Security.Cryptography.SHA256]::Create()
$actual = $sha256.ComputeHash($bytes)
$hash = ([BitConverter]::ToString($actual)).Replace("-", "")
if ($hash -ne $expectedHash) {
$modulesOutput += "WARNING: Protected file altered: '$($file.FullName)'"
}
} catch {}
}
}
$modulesOutput += "SUCCESS: Protected module intact."
}
} else {
foreach ($file in $unauthorizedFiles) {
try {
$file.Attributes = 'Normal'
Remove-Item $file.FullName -Force -ErrorAction Stop
$modulesOutput += "FAILURE: Removed unauthorized file: '$($file.FullName)'"
$deletedAny = $true
} catch {
$modulesOutput += "WARNING: Could not delete file '$($file.FullName)'"
}
}
if ($unauthorizedFiles.Count -eq 0) {
$modulesOutput += "SUCCESS: Module '$moduleName' passed signature check."
}
}
}
# Check files in module root
Get-ChildItem $modulesPath -Force -ErrorAction SilentlyContinue | Where-Object { -not $_.PSIsContainer } | ForEach-Object {
$sig = Get-AuthenticodeSignature $_.FullName
if ($sig.Status -ne 'Valid' -or $sig.SignerCertificate.Subject -notmatch "Microsoft") {
try {
Remove-Item $_.FullName -Force
$modulesOutput += "FAILURE: Removed unsigned file: '$($_.FullName)'"
$deletedAny = $true
} catch {
$modulesOutput += "WARNING: Could not delete root file '$($_.FullName)'"
}
} else {
$modulesOutput += "SUCCESS: Root file '$($_.Name)' is signed."
}
}
if (-not $deletedAny) {
$modulesOutput += "SUCCESS: No unauthorized modules/files found."
}
# OS Check
try {
if ($env:OS -eq "Windows_NT" -and (Get-CimInstance Win32_OperatingSystem -ErrorAction Stop)) {
$windowsOutput += "SUCCESS: Running on Windows."
} else {
$windowsOutput += "FAILURE: Not running on Windows."
}
} catch {
$windowsOutput += "FAILURE: OS check failed."
}
# Memory Integrity
try {
$regPath = "HKLM:\SYSTEM\CurrentControlSet\Control\DeviceGuard\Scenarios\HypervisorEnforcedCodeIntegrity"
$enabled = Get-ItemPropertyValue -Path $regPath -Name "Enabled" -ErrorAction Stop
$memoryIntegrityOutput += "SUCCESS: Memory Integrity supported."
if ($enabled -eq 1) {
$memoryIntegrityOutput += "SUCCESS: Memory Integrity is ON."
} else {
$memoryIntegrityOutput += "FAILURE: Memory Integrity is OFF."
}
} catch {
$memoryIntegrityOutput += "FAILURE: Memory Integrity not supported or inaccessible."
}
# Defender
try {
$defender = Get-MpComputerStatus
if ($defender.AMServiceEnabled) {
if (-not $defender.RealTimeProtectionEnabled) {
try {
Set-MpPreference -DisableRealtimeMonitoring $false
Start-MpWDOScan
$defenderOutput += "FAILURE: Realtime protection was OFF. Enabling..."
} catch {
$defenderOutput += "WARNING: Could not re-enable Defender."
}
} else {
$defenderOutput += "SUCCESS: Realtime protection is ON."
}
} else {
$defenderOutput += "FAILURE: Defender is not running."
}
} catch {
$defenderOutput += "WARNING: Defender status unavailable."
}
# Exclusions
try {
$exclusions = Get-MpPreference | Select-Object -ExpandProperty ExclusionPath
if ($exclusions) {
$exclusionsOutput += "FAILURE: Exclusion paths found:`n$($exclusions -join "`n")"
} else {
$exclusionsOutput += "SUCCESS: No Defender exclusions set."
}
} catch {
$exclusionsOutput += "WARNING: Could not check exclusions."
}
# Threats
try {
$threats = Get-MpThreat | Where-Object { $_.Status -eq "Active" }
if ($threats) {
foreach ($t in $threats) {
$threatsOutput += "FAILURE: $($t.ThreatName) | $($t.Resources)"
}
} else {
$threatsOutput += "SUCCESS: No active threats."
}
} catch {
$threatsOutput += "WARNING: Threat scan failed."
}
# PowerShell Signature
try {
$psPath = "$env:SystemRoot\System32\WindowsPowerShell\v1.0\powershell.exe"
$sig = Get-AuthenticodeSignature -FilePath $psPath
if ($sig.Status -eq 'Valid' -and $sig.SignerCertificate.Subject -like '*Microsoft Windows*') {
$powershellSigOutput += "SUCCESS: PowerShell is signed and valid."
} else {
$powershellSigOutput += "FAILURE: PowerShell binary signature invalid."
}
} catch {
$powershellSigOutput += "WARNING: Could not verify PowerShell binary."
}
# Helper to print sections without blank lines between
function Write-Section {
param([string]$Title, [string[]]$Lines)
Write-Host "--- $Title ---" -ForegroundColor White
foreach ($line in $Lines) {
if ($line -match "^SUCCESS") { Write-Host $line -ForegroundColor Green }
elseif ($line -match "^FAILURE") { Write-Host $line -ForegroundColor Red }
elseif ($line -match "^WARNING") { Write-Host $line -ForegroundColor Yellow }
else { Write-Host $line -ForegroundColor White }
}
}
# Print Results compactly (no blank lines between sections)
Write-Section "Files + Modules" $modulesOutput
Write-Section "OS Check" $windowsOutput
Write-Section "Memory Integrity" $memoryIntegrityOutput
Write-Section "Windows Defender" $defenderOutput
Write-Section "Exclusions" $exclusionsOutput
Write-Section "Threats" $threatsOutput
Write-Section "Binary Sig" $powershellSigOutput
# Summary
$allResults = $modulesOutput + $windowsOutput + $memoryIntegrityOutput + $defenderOutput + $exclusionsOutput + $threatsOutput + $powershellSigOutput
$total = ($allResults | Where-Object { $_ -match '^(SUCCESS|FAILURE|WARNING)' }).Count
$success = ($allResults | Where-Object { $_ -match '^SUCCESS' }).Count
$failure = ($allResults | Where-Object { $_ -match '^FAILURE' }).Count
$warning = ($allResults | Where-Object { $_ -match '^WARNING' }).Count
$rate = if ($total -gt 0) { [math]::Round(($success / $total) * 100, 2) } else { 0 }
$rateColor = if ($rate -eq 100) { "Green" } else { "Red" }
Write-Host ""
Write-Host ("Success Rate: $rate% ($success / $total)") -ForegroundColor $rateColor
Read-Host "Press Enter to continue..."
Clear-Host 
