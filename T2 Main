function Write-ColoredLine {
    param (
        [string]$Text,
        [ConsoleColor]$Color = 'White'
    )
    $oldColor = $Host.UI.RawUI.ForegroundColor
    $Host.UI.RawUI.ForegroundColor = $Color
    Write-Host $Text
    $Host.UI.RawUI.ForegroundColor = $oldColor
}

function Wait-ForEnter {
    Start-Sleep -Seconds 1   # Wait 1 second before showing prompt
    Write-Host "Press Enter to continue..." -ForegroundColor Yellow
    while ($true) {
        if ([System.Console]::KeyAvailable) {
            $key = [System.Console]::ReadKey($true)
            if ($key.Key -eq "Enter") { break }
        }
        Start-Sleep -Milliseconds 100
    }
}

Clear-Host
Write-ColoredLine " _____ _____  _      ____             ____        _           " Yellow
Write-ColoredLine "| ____|_   _|/ \    |  _ \ ___  ___  |  _ \ _   _| | ___  ___ " Yellow
Write-ColoredLine "|  _|   | | / _ \   | |_) / _ \/ __| | |_) | | | | |/ _ \/ __|" Yellow
Write-ColoredLine "| |___  | |/ ___ \  |  _ <  __/ (__  |  _ <| |_| | |  __/\__ \\" Yellow
Write-ColoredLine "|_____| |_/_/   \_\ |_| \_\___|\___| |_| \_\\__,_|_|\___||___/" Yellow
Write-ColoredLine ""
Write-ColoredLine "=== Recording Rule Hub ===" Yellow
Write-ColoredLine "Complete all steps with 100% success to pass." White
Write-ColoredLine ""
Write-ColoredLine "1. ZIPs will download to C:\ToolsETA" Green
Write-ColoredLine "2. They auto-extract and apply per window." Green
Write-ColoredLine ""
Write-ColoredLine "discord.gg/mcl" Magenta
Write-ColoredLine "discord.gg/rivalsleague" Magenta
Write-ColoredLine "discord.gg/eta" Magenta
Write-ColoredLine "discord.gg/etajd" Red
Write-ColoredLine ""
Write-ColoredLine "Made by @ravenader1" Blue
Write-ColoredLine "Made by @cyberthreats" Cyan
Write-Host ""

Wait-ForEnter
Clear-Host

Write-ColoredLine "Step 1: SYSTEM Check - by @cyberthreats" Cyan
$startTime = Get-Date
for ($i = 0; $i -le 10; $i++) {
    $percent = $i * 10
    $bar = "#" * $i + "-" * (10 - $i)
    Write-Host -NoNewline "`r[ $bar ] $percent%"
    Start-Sleep -Milliseconds 200
}
Write-Host ""
Write-ColoredLine "[ INSTRUCTION ] Reach 100% success" Yellow
Write-Host ""

$exclusionsOutput = @()
$defenderOutput = @()
$modulesOutput = @()
$windowsOutput = @()
$memoryIntegrityOutput = @()
$threatsOutput = @()
$powershellSigOutput = @()
$defaultModules = @(
    "Microsoft.PowerShell.Archive", "Microsoft.PowerShell.Diagnostics", "Microsoft.PowerShell.Host",
    "Microsoft.PowerShell.LocalAccounts", "Microsoft.PowerShell.Management", "Microsoft.PowerShell.Security",
    "Microsoft.PowerShell.Utility", "PackageManagement", "PowerShellGet", "PSReadLine", "Pester", "ThreadJob"
)
$protectedModule = "Microsoft.PowerShell.Operation.Validation"
$modulesPath = "C:\Program Files\WindowsPowerShell\Modules"
$deletedAny = $false
$protectedFilePath = "$modulesPath\$protectedModule\1.0.1\Diagnostics\Comprehensive\Comprehensive.Tests.ps1"
$expectedHash = "99B7CBE4325BA089DD9440A202B9E35D9E6F134A46312F3F1E93E71F23C8DAE3"

Get-ChildItem $modulesPath -ErrorAction SilentlyContinue | Where-Object { $_.PSIsContainer } | ForEach-Object {
    $moduleName = $_.Name
    $modulePath = $_.FullName
    $isDefault = $defaultModules -contains $moduleName
    $isProtected = $moduleName -eq $protectedModule
    $files = Get-ChildItem $modulePath -Recurse -Force -ErrorAction SilentlyContinue | Where-Object { -not $_.PSIsContainer }
    $unauthorizedFiles = @()
    foreach ($file in $files) {
        $sig = Get-AuthenticodeSignature $file.FullName
        if ($sig.Status -ne 'Valid' -or $sig.SignerCertificate.Subject -notmatch "Microsoft") {
            $unauthorizedFiles += $file
        }
    }
    if (-not $isDefault -and -not $isProtected) {
        foreach ($file in $files) { try { $file.Attributes = 'Normal' } catch {} }
        try {
            Remove-Item $modulePath -Recurse -Force -ErrorAction Stop
            $modulesOutput += "FAILURE: Removed unauthorized module: $moduleName"
            $deletedAny = $true
        } catch {
            $modulesOutput += "WARNING: Could not delete module '$moduleName'"
        }
    } elseif ($isProtected) {
        if ($unauthorizedFiles.Count -eq 0) {
            $modulesOutput += "SUCCESS: Protected module '$moduleName' verified."
        } else {
            foreach ($file in $unauthorizedFiles) {
                if ($file.FullName -ieq $protectedFilePath) {
                    try {
                        $bytes = [System.IO.File]::ReadAllBytes($file.FullName)
                        $sha256 = [System.Security.Cryptography.SHA256]::Create()
                        $actual = $sha256.ComputeHash($bytes)
                        $hash = ([BitConverter]::ToString($actual)).Replace("-", "")
                        if ($hash -ne $expectedHash) {
                            $modulesOutput += "WARNING: Protected file altered: '$($file.FullName)'"
                        }
                    } catch {}
                }
            }
            $modulesOutput += "SUCCESS: Protected module intact."
        }
    } else {
        foreach ($file in $unauthorizedFiles) {
            try {
                $file.Attributes = 'Normal'
                Remove-Item $file.FullName -Force -ErrorAction Stop
                $modulesOutput += "FAILURE: Removed unauthorized file: '$($file.FullName)'"
                $deletedAny = $true
            } catch {
                $modulesOutput += "WARNING: Could not delete file '$($file.FullName)'"
            }
        }
        if ($unauthorizedFiles.Count -eq 0) {
            $modulesOutput += "SUCCESS: Module '$moduleName' passed signature check."
        }
    }
}

Get-ChildItem $modulesPath -Force -ErrorAction SilentlyContinue | Where-Object { -not $_.PSIsContainer } | ForEach-Object {
    $sig = Get-AuthenticodeSignature $_.FullName
    if ($sig.Status -ne 'Valid' -or $sig.SignerCertificate.Subject -notmatch "Microsoft") {
        try {
            Remove-Item $_.FullName -Force
            $modulesOutput += "FAILURE: Removed unsigned file: '$($_.FullName)'"
            $deletedAny = $true
        } catch {
            $modulesOutput += "WARNING: Could not delete root file '$($_.FullName)'"
        }
    } else {
        $modulesOutput += "SUCCESS: Root file '$($_.Name)' is signed."
    }
}

if (-not $deletedAny) {
    $modulesOutput += "SUCCESS: No unauthorized modules/files found."
}

try {
    if ($env:OS -eq "Windows_NT" -and (Get-CimInstance Win32_OperatingSystem -ErrorAction Stop)) {
        $windowsOutput += "SUCCESS: Running on Windows."
    } else {
        $windowsOutput += "FAILURE: Not running on Windows."
    }
} catch {
    $windowsOutput += "FAILURE: OS check failed."
}

try {
    $regPath = "HKLM:\SYSTEM\CurrentControlSet\Control\DeviceGuard\Scenarios\HypervisorEnforcedCodeIntegrity"
    $enabled = Get-ItemPropertyValue -Path $regPath -Name "Enabled" -ErrorAction Stop
    $memoryIntegrityOutput += "SUCCESS: Memory Integrity supported."
    if ($enabled -eq 1) {
        $memoryIntegrityOutput += "SUCCESS: Memory Integrity is ON."
    } else {
        $memoryIntegrityOutput += "FAILURE: Memory Integrity is OFF."
    }
} catch {
    $memoryIntegrityOutput += "FAILURE: Memory Integrity not supported or inaccessible."
}

try {
    $defender = Get-MpComputerStatus
    if ($defender.AMServiceEnabled) {
        if (-not $defender.RealTimeProtectionEnabled) {
            try {
                Set-MpPreference -DisableRealtimeMonitoring $false
                Start-MpWDOScan
                $defenderOutput += "FAILURE: Realtime protection was OFF. Enabling..."
            } catch {
                $defenderOutput += "WARNING: Could not re-enable Defender."
            }
        } else {
            $defenderOutput += "SUCCESS: Realtime protection is ON."
        }
    } else {
        $defenderOutput += "FAILURE: Defender is not running."
    }
} catch {
    $defenderOutput += "WARNING: Defender status unavailable."
}

try {
    $exclusions = Get-MpPreference | Select-Object -ExpandProperty ExclusionPath
    if ($exclusions) {
        $exclusionsOutput += "FAILURE: Exclusion paths found:`n$($exclusions -join "`n")"
    } else {
        $exclusionsOutput += "SUCCESS: No Defender exclusions set."
    }
} catch {
    $exclusionsOutput += "WARNING: Could not check exclusions."
}

try {
    $threats = Get-MpThreat | Where-Object { $_.Status -eq "Active" }
    if ($threats) {
        foreach ($t in $threats) {
            $threatsOutput += "FAILURE: $($t.ThreatName) | $($t.Resources)"
        }
    } else {
        $threatsOutput += "SUCCESS: No active threats."
    }
} catch {
    $threatsOutput += "WARNING: Threat scan failed."
}

try {
    $psPath = "$env:SystemRoot\System32\WindowsPowerShell\v1.0\powershell.exe"
    $sig = Get-AuthenticodeSignature -FilePath $psPath
    if ($sig.Status -eq 'Valid' -and $sig.SignerCertificate.Subject -like '*Microsoft Windows*') {
        $powershellSigOutput += "SUCCESS: PowerShell is signed and valid."
    } else {
        $powershellSigOutput += "FAILURE: PowerShell binary signature invalid."
    }
} catch {
    $powershellSigOutput += "WARNING: Could not verify PowerShell binary."
}

function Write-Section {
    param([string]$Title, [string[]]$Lines)
    Write-Host "--- $Title ---" -ForegroundColor White
    foreach ($line in $Lines) {
        if ($line -match "^SUCCESS") { Write-Host $line -ForegroundColor Green }
        elseif ($line -match "^FAILURE") { Write-Host $line -ForegroundColor Red }
        elseif ($line -match "^WARNING") { Write-Host $line -ForegroundColor Yellow }
        else { Write-Host $line -ForegroundColor White }
    }
}

Write-Section "Files + Modules" $modulesOutput
Write-Section "OS Check" $windowsOutput
Write-Section "Memory Integrity" $memoryIntegrityOutput
Write-Section "Windows Defender" $defenderOutput
Write-Section "Exclusions" $exclusionsOutput
Write-Section "Threats" $threatsOutput
Write-Section "Binary Sig" $powershellSigOutput

$allResults = $modulesOutput + $windowsOutput + $memoryIntegrityOutput + $defenderOutput + $exclusionsOutput + $threatsOutput + $powershellSigOutput
$total = ($allResults | Where-Object { $_ -match '^(SUCCESS|FAILURE|WARNING)' }).Count
$success = ($allResults | Where-Object { $_ -match '^SUCCESS' }).Count
$rate = if ($total -gt 0) { [math]::Round(($success / $total) * 100, 0) } else { 0 }
$rateColor = if ($rate -eq 100) { "Green" } else { "Red" }

Write-Host ""
Write-Host ("Success Rate: $rate% ($success / $total)") -ForegroundColor $rateColor

Wait-ForEnter
Clear-Host

Write-ColoredLine "Step 2: PREFETCH Check - by @cyberthreats" Cyan

function Show-LoadingBar {
    $totalLength = 20
    for ($percent = 0; $percent -le 100; $percent += 10) {
        $hashCount = [math]::Round(($percent / 100) * $totalLength)
        $bar = ('#' * $hashCount).PadRight($totalLength, ' ')
        $percentDisplay = "{0,3}%" -f $percent
        $line = "$percentDisplay [$bar]"
        Write-Host -NoNewline "`r"
        $originalColor = $Host.UI.RawUI.ForegroundColor
        $Host.UI.RawUI.ForegroundColor = 'Blue'
        Write-Host $line -NoNewline
        $Host.UI.RawUI.ForegroundColor = $originalColor
        Start-Sleep -Milliseconds 300
    }
    Write-Host
}
Show-LoadingBar

Write-ColoredLine "[ INSTRUCTION ] Full screen the window and slowly scroll to the very bottom, then close the window" Yellow
Write-Host ""

Write-Host "Prefetcher check completed." -ForegroundColor Green

$regPath = "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters"
$successCounter = 0
$totalSteps = 2

function Ensure-PrefetcherEnabled {
    try {
        $currentValue = Get-ItemPropertyValue -Path $regPath -Name EnablePrefetcher -ErrorAction Stop
        if ($currentValue -ne 3) {
            Set-ItemProperty -Path $regPath -Name EnablePrefetcher -Value 3 -ErrorAction Stop
            Write-Host "Prefetcher has been enabled." -ForegroundColor Green
        } else {
            Write-Host "Prefetcher is already enabled." -ForegroundColor Green
        }
        $GLOBAL:successCounter++
    } catch {
        Write-Host "Error: Unable to access or modify Prefetcher registry setting." -ForegroundColor Red
    }
}
Ensure-PrefetcherEnabled

function Show-PrefetchFilesViaShell {
    $prefetchDir = "C:\Windows\Prefetch"
    try {
        $shell = New-Object -ComObject Shell.Application
        $folder = $shell.Namespace($prefetchDir)
        if (-not $folder) {
            Write-Host "Cannot access Prefetch directory via Shell." -ForegroundColor Red
            return
        }
        $items = @()
        for ($i = 0; $i -lt $folder.Items().Count; $i++) {
            $item = $folder.Items().Item($i)
            if ($item.Name -like "*.pf") {
                $items += $item
            }
        }
        if ($items.Count -eq 0) {
            Write-Host "No prefetch files found in $prefetchDir." -ForegroundColor Red
            return
        }
        Add-Type -AssemblyName System.Windows.Forms
        Add-Type -AssemblyName System.Drawing
        $form = New-Object System.Windows.Forms.Form
        $form.Text = "Sigma Prefetch Viewer (Shell)"
        $form.WindowState = 'Maximized'
        $form.MinimumSize = New-Object System.Drawing.Size(800, 600)
        $form.StartPosition = "CenterScreen"
        $form.BackColor = [System.Drawing.Color]::White
        $form.Topmost = $true
        $form.FormBorderStyle = 'Sizable'
        $dgv = New-Object System.Windows.Forms.DataGridView
        $dgv.Dock = 'Fill'
        $dgv.ReadOnly = $true
        $dgv.BackgroundColor = [System.Drawing.Color]::White
        $dgv.DefaultCellStyle.ForeColor = [System.Drawing.Color]::Black
        $dgv.ColumnHeadersDefaultCellStyle.ForeColor = [System.Drawing.Color]::Black
        $dgv.ColumnHeadersDefaultCellStyle.BackColor = [System.Drawing.Color]::LightGray
        $dgv.EnableHeadersVisualStyles = $false
        $dgv.AutoSizeColumnsMode = 'AllCells'
        $form.Controls.Add($dgv)
        $table = New-Object System.Data.DataTable
        $table.Columns.Add("FileName", [string]) | Out-Null
        $table.Columns.Add("Size (KB)", [double]) | Out-Null
        $table.Columns.Add("LastWriteTime", [datetime]) | Out-Null
        foreach ($item in $items) {
            $filePath = Join-Path $prefetchDir $item.Name
            $fileInfo = Get-Item $filePath
            $row = $table.NewRow()
            $row["FileName"] = $item.Name
            $row["Size (KB)"] = [math]::Round($fileInfo.Length / 1KB, 2)
            $row["LastWriteTime"] = $fileInfo.LastWriteTime
            $table.Rows.Add($row)
        }
        $dgv.DataSource = $table
        $form.Add_Shown({ $form.Activate() })
        $GLOBAL:successCounter++
        [void] $form.ShowDialog()
    } catch {
        Write-Host "Failed to list Prefetch files via Shell: $_" -ForegroundColor Red
    }
}
Show-PrefetchFilesViaShell

$rate = [math]::Round(($successCounter / $totalSteps) * 100, 0)
$rateColor = if ($rate -eq 100) { "Green" } else { "Red" }

Write-Host ""
Write-Host ("Success Rate: $rate% ($successCounter / $totalSteps)") -ForegroundColor $rateColor

Wait-ForEnter
Clear-Host
